<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="description" content="A walkthrough on how to build your own lexer with automatic semicolon insertion!">
    <meta name="author" content="Diego Frias">
    <meta name="robots" content="follow, index, max-snippet:-1, max-video-preview:-1, max-image-preview:large">
    <title>Build a Lexer with Automatic Semicolon Insertion in Rust - dzfrias</title>
    
<script type="module" src="/js/index.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">

    <link rel="stylesheet" href="/css/style.css">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#0f0f0f">
    <meta name="theme-color" content="#0f0f0f">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link rel="preconnect" href="https://fonts.gstatic.com"><link data-href="https://fonts.googleapis.com/css2?family=Frank+Ruhl+Libre:wght@300..900&display=swap" rel="stylesheet"><style data-href="https://fonts.googleapis.com/css2?family=Frank+Ruhl+Libre:wght@300..900&display=swap">/* hebrew */
@font-face {
  font-family: 'Frank Ruhl Libre';
  font-style: normal;
  font-weight: 300 900;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/frankruhllibre/v21/j8_w6_fAw7jrcalD7oKYNX0QfAnPW7Ll4brkiY-xBg.woff2) format('woff2');
  unicode-range: U+0307-0308, U+0590-05FF, U+200C-2010, U+20AA, U+25CC, U+FB1D-FB4F;
}
/* latin-ext */
@font-face {
  font-family: 'Frank Ruhl Libre';
  font-style: normal;
  font-weight: 300 900;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/frankruhllibre/v21/j8_w6_fAw7jrcalD7oKYNX0QfAnPW77l4brkiY-xBg.woff2) format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Frank Ruhl Libre';
  font-style: normal;
  font-weight: 300 900;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/frankruhllibre/v21/j8_w6_fAw7jrcalD7oKYNX0QfAnPW7Dl4brkiY8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
</style>
  </head>
  <body>
    
<div aria-hidden="true" class="progress-bar"><div class="progress-bar-inner"></div></div>

    <div id="main-left">
      
<nav class="toc">
        <ol><li><a href="#getting-started">Getting Started</a><ol><li><a href="#defining-our-token-type">Defining our Token Type</a></li><li><a href="#defining-our-lexer">Defining our Lexer</a></li><li><a href="#fundamental-methods">Fundamental Methods</a></li></ol></li><li><a href="#a-basic-%22next-token%22-method">A Basic &quot;Next Token&quot; Method</a></li><li><a href="#a-peek-buffer">A Peek Buffer</a></li><li><a href="#reading-identifiers">Reading Identifiers</a></li><li><a href="#whitespace">Whitespace</a></li><li><a href="#automatic-semicolon-insertion">Automatic Semicolon Insertion</a></li><li><a href="#wrapping-up">Wrapping Up</a></li></ol>
      </nav>

    </div>
    <div id="main-content">
      <header>
        <nav>
          <a href="/" aria-label="Home">
            <div class="header-logo">
              <svg class="profile" viewBox="0 0 200 200" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_1_2)">
<rect width="200" height="200" fill="#7B7B7B"></rect>
<path d="M-50 -50L245 245L-50 240.719V-50Z" fill="#040404"></path>
<path d="M98.45 34.8C106.25 34.2 110.1 33.9 110 33.9C110.9 33.9 111.5 34.25 111.8 34.95C111.9 35.35 108.3 50.25 101 79.65L89.6 125.25C89.4 127.55 89.4 129.4 89.6 130.8C89.8 131.3 90.1 131.7 90.5 132C90.8 132.3 91.25 132.45 91.85 132.45C92.55 132.45 93.1 132.35 93.5 132.15C95.4 130.75 97.35 126.2 99.35 118.5C99.85 116.6 100.25 115.55 100.55 115.35C100.75 115.15 101.95 115.05 104.15 115.05C106.35 115.05 107.6 115.15 107.9 115.35C108.1 115.55 108.2 115.95 108.2 116.55C108.2 117.15 107.95 118.35 107.45 120.15C103.75 132.75 98.5 139.25 91.7 139.65C86.6 139.95 82.5 138.2 79.4 134.4C78.9 133.8 78.45 133.15 78.05 132.45C77.85 131.85 77.7 131.55 77.6 131.55L76.55 132.45C73.05 135.55 69.6 137.6 66.2 138.6C59.7 140.8 53.85 139.8 48.65 135.6C48.05 135.1 47.5 134.55 47 133.95C45.5 132.45 44.25 130.65 43.25 128.55C40.75 123.45 39.95 117.4 40.85 110.4C42.45 99 47.3 89.4 55.4 81.6C60.6 76.6 66.25 73.45 72.35 72.15C73.25 71.95 74.65 71.85 76.55 71.85C79.05 71.85 81.2 72.25 83 73.05C84.4 73.75 85.7 74.7 86.9 75.9C87.7 76.7 88.1 77 88.1 76.8C88.2 76.7 89.45 71.9 91.85 62.4C94.15 53.1 95.35 47.9 95.45 46.8C95.45 45.9 95.35 45.35 95.15 45.15C94.45 44.45 92.3 44.05 88.7 43.95C86.3 43.95 84.9 43.6 84.5 42.9L84.35 42.45L85.1 39.45C85.5 37.55 85.9 36.4 86.3 36C86.6 35.7 86.9 35.55 87.2 35.55L98.45 34.8ZM77.15 78.9C73.05 78.2 69.1 80.15 65.3 84.75C64.3 86.05 63.4 87.45 62.6 88.95C61.1 91.85 59.3 97.55 57.2 106.05C55.9 110.85 54.95 115.05 54.35 118.65C53.95 122.05 53.95 124.65 54.35 126.45C55.35 129.95 57.3 131.95 60.2 132.45C61.9 132.75 63.95 132.4 66.35 131.4C69.95 129.4 73.35 126.05 76.55 121.35L77.3 120.3L81.05 105.3L84.8 90.3L84.5 89.25C83.6 83.55 81.4 80.15 77.9 79.05C77.7 78.95 77.45 78.9 77.15 78.9ZM154.811 32.4C155.311 32.3 156.311 32.25 157.811 32.25C160.111 32.35 162.211 32.9 164.111 33.9C168.011 35.9 169.961 39.1 169.961 43.5C169.961 45.3 169.561 47 168.761 48.6C168.361 49.6 167.761 50.45 166.961 51.15C165.961 52.15 165.111 52.8 164.411 53.1C161.611 54.4 158.961 54.45 156.461 53.25C153.961 51.95 153.061 49.65 153.761 46.35C153.861 45.95 153.961 45.55 154.061 45.15C154.761 42.85 156.011 41.15 157.811 40.05C158.311 39.75 157.961 39.5 156.761 39.3C156.061 39.3 155.561 39.4 155.261 39.6C154.461 40.2 153.911 40.9 153.611 41.7C153.211 42.5 152.161 47.1 150.461 55.5C148.161 66.5 147.011 72.4 147.011 73.2C147.011 73.3 149.711 73.35 155.111 73.35H163.211L163.811 73.8C164.211 74.3 164.161 75.65 163.661 77.85C163.161 80.05 162.711 81.25 162.311 81.45C162.011 81.65 159.111 81.75 153.611 81.75C148.111 81.75 145.361 81.85 145.361 82.05L141.461 101.85L136.961 125.1C134.261 138.1 131.661 147.4 129.161 153C125.961 160.4 121.861 165.25 116.861 167.55C115.461 168.25 113.961 168.65 112.361 168.75C107.961 168.95 104.461 167.6 101.861 164.7C101.661 164.6 101.511 164.45 101.411 164.25C100.011 162.25 99.3113 160.05 99.3113 157.65C99.3113 155.75 99.7113 154 100.511 152.4C100.911 151.4 101.511 150.55 102.311 149.85C103.311 148.85 104.161 148.2 104.861 147.9C107.661 146.6 110.311 146.55 112.811 147.75C115.311 149.05 116.211 151.35 115.511 154.65C115.411 155.05 115.311 155.45 115.211 155.85C114.511 158.15 113.261 159.85 111.461 160.95C110.861 161.35 111.211 161.55 112.511 161.55C113.311 161.55 113.911 161.4 114.311 161.1C115.611 160.1 116.611 157.5 117.311 153.3C118.311 147 119.811 139.9 121.811 132L124.811 118.5C129.511 93.4 131.861 81.2 131.861 81.9C131.861 81.8 129.561 81.75 124.961 81.75C120.061 81.75 117.411 81.4 117.011 80.7C116.811 80.4 116.961 79.25 117.461 77.25C117.961 75.25 118.361 74.1 118.661 73.8L119.111 73.35H126.311H133.511V73.05L135.011 65.7C137.011 55.3 138.961 48.05 140.861 43.95C143.961 37.65 148.611 33.8 154.811 32.4Z" fill="white"></path>
</g>
<defs>
<clipPath id="clip0_1_2">
<rect width="200" height="200" fill="white"></rect>
</clipPath>
</defs>
</svg>

            </div>
          </a>
          <ul>
            
            <li>
              <a href="/blog/">Blog</a>
            </li>
            
            <li>
              <a href="/projects/">Projects</a>
            </li>
            
            <li>
              <a href="https://github.com/dzfrias">GitHub</a>
            </li>
            
          </ul>
        </nav>
      </header>
      <main tabindex="-1">
        
<h1>Build a Lexer with Automatic Semicolon Insertion in Rust</h1>
<p>If you're looking to write a programming language, it's very likely that you'll
need a <strong>lexer</strong>. Lexers are immensely helpful in the parsing process, and can
even allow you to have (fancy) semicolon-less syntax. However, building a lexer
can be a bit confusing, especially one with automatic semicolon insertion. In
this post, you'll learn how to write your own lexer with the following features:</p>
<ul>
<li>Basic token handling</li>
<li><a href="https://go.dev/ref/spec#Semicolons">Go-style automatic semicolon insertion</a></li>
<li>Insignificant whitespace</li>
</ul>
<p>This post also assumes you have <em>some familiarity</em> with Rust; you won't have to
have a deep knowledge or familiarity of the language, just your way around the
syntax.</p>
<h2 id="getting-started" tabindex="-1"><a class="header-anchor" href="#getting-started">Getting Started</a></h2>
<p>If you know nothing about lexers, they essentially take your program's raw
string input and turn it into a <strong>stream of tokens</strong>. A token represents a
single unit in your syntax. Lexers are helpful for writing parsers, as the
parsers don't have to work with strings anymore, instead receiving well-defined
pieces of your program.</p>
<p>Here are some examples of what lexers would do with your input:</p>
<pre class="language-text"><code class="language-text">"i + x" becomes Token::Ident("i"), Token::Plus, Token::Ident("x")
"x = y" becomes Token::Ident("x"), Token::Assign, Token::Ident("y")</code></pre>
<h3 id="defining-our-token-type" tabindex="-1"><a class="header-anchor" href="#defining-our-token-type">Defining our Token Type</a></h3>
<p>First, we should define what our possible tokens should be. In this post, we
will cover only a small subset of what is realistic in a general-purpose
programming language, but you'll hopefully have enough knowledge to extend the
lexer as you wish!</p>
<pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug, PartialEq)]</span>
<span class="token keyword">pub</span> <span class="token keyword">enum</span> <span class="token type-definition class-name">Token</span> <span class="token punctuation">{</span>
    <span class="token class-name">Illegal</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// Denotes when our input ends</span>
    <span class="token constant">EOF</span><span class="token punctuation">,</span>

    <span class="token comment">// In programming languages, identifiers are usually used for variable names</span>
    <span class="token class-name">Ident</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Assign</span><span class="token punctuation">,</span>
    <span class="token class-name">Plus</span><span class="token punctuation">,</span>
    <span class="token class-name">Minus</span><span class="token punctuation">,</span>
    <span class="token class-name">Bang</span><span class="token punctuation">,</span>
    <span class="token class-name">Asterisk</span><span class="token punctuation">,</span>
    <span class="token class-name">Slash</span><span class="token punctuation">,</span>

    <span class="token comment">// &lt;</span>
    <span class="token class-name">Langle</span><span class="token punctuation">,</span>
    <span class="token comment">// ></span>
    <span class="token class-name">Rangle</span><span class="token punctuation">,</span>
    <span class="token class-name">Eq</span><span class="token punctuation">,</span>
    <span class="token class-name">NotEq</span><span class="token punctuation">,</span>
    <span class="token comment">// >=</span>
    <span class="token class-name">Ge</span><span class="token punctuation">,</span>
    <span class="token comment">// &lt;=</span>
    <span class="token class-name">Le</span><span class="token punctuation">,</span>

    <span class="token comment">// Semicolons ARE in the language, just not usually written by the programmer</span>
    <span class="token class-name">Semicolon</span><span class="token punctuation">,</span>
    <span class="token class-name">Comma</span><span class="token punctuation">,</span>

    <span class="token class-name">Lparen</span><span class="token punctuation">,</span>
    <span class="token class-name">Rparen</span><span class="token punctuation">,</span>
    <span class="token class-name">Lbrace</span><span class="token punctuation">,</span>
    <span class="token class-name">Rbrace</span><span class="token punctuation">,</span>

    <span class="token comment">// The only keyword in our language. This can easily be extended!</span>
    <span class="token class-name">Return</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre>
<p>These are the tokens that make up the language's syntax!</p>
<h3 id="defining-our-lexer" tabindex="-1"><a class="header-anchor" href="#defining-our-lexer">Defining our Lexer</a></h3>
<p>I'll start by explaining what our lexer will actually do. Our lexer is basically
an iterator that yields <code>Token</code>s. It has a single public method, <code>next_token()</code>,
that advances the iterator and returns a single <code>Token</code>.</p>
<p>To accomplish this, our lexer essentially has a pointer to a place in our input.
When <code>next_token()</code> is called, the lexer returns what it pointed to and then
advances to the start of the next token.</p>
<pre class="language-rust"><code class="language-rust"><span class="token comment">// Asumming an input of "+ =="</span>

<span class="token comment">// ===INITIAL STATE===</span>

<span class="token comment">// input: + ==</span>
<span class="token comment">// lexer: ^</span>

<span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Plus</span><span class="token punctuation">,</span> lexer<span class="token punctuation">.</span><span class="token function">next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// ===NEW STATE===</span>

<span class="token comment">// input: + ==</span>
<span class="token comment">// lexer:   ^</span>

<span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Eq</span><span class="token punctuation">,</span> lexer<span class="token punctuation">.</span><span class="token function">next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// ===NEW STATE===</span>
<span class="token comment">//</span>
<span class="token comment">// input: + ==</span>
<span class="token comment">// lexer:     ^</span></code></pre>
<p>We'll start by writing the basic layout of our Lexer struct.</p>
<pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Lexer</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token punctuation">{</span>
    input<span class="token punctuation">:</span> <span class="token class-name">Chars</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span><span class="token punctuation">,</span>
    current<span class="token punctuation">:</span> <span class="token keyword">char</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre>
<p>First off, our lexer is generic over the lifetime <code>'a</code>, as a result of <code>Chars</code>.
<code>Chars</code> is an iterator that yields <code>char</code>s, and is tied to our program's input
(<code>&amp;'a str</code>). Much like how our lexer yields <code>Token</code>s, <code>Chars</code> yields <code>char</code>s.</p>
<p>We also have <code>current</code>, which is the current character that our lexer's pointer
points to.</p>
<p>With this foundation, hopefully you now know what our lexer does! We'll get
started with some of the fundamental methods we'll need to get it operational.</p>
<h3 id="fundamental-methods" tabindex="-1"><a class="header-anchor" href="#fundamental-methods">Fundamental Methods</a></h3>
<p>Let's first write a constructor for our lexer.</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token class-name">Lexer</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> <span class="token keyword">mut</span> lexer <span class="token operator">=</span> <span class="token keyword">Self</span> <span class="token punctuation">{</span>
          input<span class="token punctuation">:</span> input<span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          current<span class="token punctuation">:</span> '\\<span class="token number">0</span>'<span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
      lexer<span class="token punctuation">.</span><span class="token function">read_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      lexer
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>It takes an <code>&amp;'a str</code>, for our program's input. We create our <code>Chars</code> based on
this input, and feed it to our lexer. We also give it a <em>placeholder</em> <code>current</code>
(the null terminator). Then, we call <code>read_char</code> to replace the placeholder we
just initialized! Wait. We haven't even defined <code>read_char</code> yet...</p>
<p><code>read_char</code> is the heart of our lexer; all it does is advance our pointer by one
character. That's it.</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">read_char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>input<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span>'\\<span class="token number">0</span>'<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>The conceptual &quot;pointer&quot; of our lexer is actually <code>Chars</code> (which is an
iterator)! You may also be wondering about the <code>unwrap_or</code> call!</p>
<p><code>self.input.next()</code> only returns <code>None</code> when our input ends. In this case, we
replace it with our null terminator so we don't have to handle it in
<code>read_char</code>. Handling the end of our input is generally something our parser
does, so this will be bubbled up in the form of <code>Token::EOF</code> when <code>next_token</code>
is called.</p>
<h2 id="a-basic-%22next-token%22-method" tabindex="-1"><a class="header-anchor" href="#a-basic-%22next-token%22-method">A Basic &quot;Next Token&quot; Method</a></h2>
<p>Now we can define the only public method we'll need on our lexer! For a
refresher, <code>Lexer::next_token()</code> should advance our pointer until a valid token
is found, and then return it.</p>
<p>Let's get a basic definition out of the way. Nothing fancy, just the super
simple tokens!</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">next_token</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Token</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> token <span class="token operator">=</span> <span class="token keyword">match</span> <span class="token keyword">self</span><span class="token punctuation">.</span>current <span class="token punctuation">{</span>
        <span class="token char">'+'</span> <span class="token operator">=></span> <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Plus</span><span class="token punctuation">,</span>
        <span class="token char">'-'</span> <span class="token operator">=></span> <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Minus</span><span class="token punctuation">,</span>
        <span class="token char">'/'</span> <span class="token operator">=></span> <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Slash</span><span class="token punctuation">,</span>
        <span class="token char">'*'</span> <span class="token operator">=></span> <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Asterisk</span><span class="token punctuation">,</span>
        <span class="token char">'('</span> <span class="token operator">=></span> <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Lparen</span><span class="token punctuation">,</span>
        <span class="token char">'{'</span> <span class="token operator">=></span> <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Lbrace</span><span class="token punctuation">,</span>
        <span class="token char">','</span> <span class="token operator">=></span> <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Comma</span><span class="token punctuation">,</span>
        <span class="token char">';'</span> <span class="token operator">=></span> <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Semicolon</span><span class="token punctuation">,</span>
        '\\<span class="token number">0</span>' <span class="token operator">=></span> <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token constant">EOF</span><span class="token punctuation">,</span>

        c <span class="token operator">=></span> <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Illegal</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">read_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    token
<span class="token punctuation">}</span></code></pre>
<p>I'm going to hold off on the closing counterparts of <code>(</code> and <code>{</code>, as those will
be candidates for our semicolon insertion. Anyway, these tokens provide a simple
implementation of the behavior visualized when we
<a href="#defining-our-lexer">defined the lexer</a>. Lets write a test!</p>
<pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[test]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">lexes_basic_tokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> lexer <span class="token operator">=</span> <span class="token class-name">Lexer</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"(,{+-*/#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> expecteds <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Lparen</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Comma</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Lbrace</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Plus</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Minus</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Asterisk</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Slash</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Illegal</span><span class="token punctuation">(</span><span class="token char">'#'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token constant">EOF</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> expecteds <span class="token punctuation">{</span>
        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> lexer<span class="token punctuation">.</span><span class="token function">next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="a-peek-buffer" tabindex="-1"><a class="header-anchor" href="#a-peek-buffer">A Peek Buffer</a></h2>
<p>Okay, now we need to handle more complicated stuff... Let's try tokenizing <code>!=</code>.
The problem with our current setup is that our lexer can't distinguish a
<code>Token::Bang</code> and a <code>Token::NotEq</code> in <code>next_token()</code>. We need some sort of
&quot;peek&quot;. When our lexer encounters a <code>!</code>, it needs to peek at the next character
and see if it's an <code>=</code>. If it is, we consume the peeked character and return
<code>Token::NotEq</code>.</p>
<p>A possible to solution to this problem is a &quot;peek buffer&quot;. When we call our
<code>peek()</code> method, the lexer should advance our pointer, and store its result in
the buffer. Then, the next time we call <code>read_char()</code>, it will try to first
consume a character from the peek buffer before advancing our <code>Chars</code> pointer
again.</p>
<p>Let's get into how we'd represent this with code.</p>
<pre class="language-diff"><code class="language-diff">#[derive(Debug)]
pub struct Lexer&lt;'a> {
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   input: Chars&lt;'a>,
</span><span class="token prefix unchanged"> </span><span class="token line">   current: char,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    peek_buffer: VecDeque&lt;char>,
</span></span>}</code></pre>
<p>We want our peek buffer to be a queue, as the behavior described above is a
first-in-first-out system. Let's add it to our constructor, too.</p>
<pre class="language-diff"><code class="language-diff">let mut lexer = Self {
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   input: input.chars(),
</span><span class="token prefix unchanged"> </span><span class="token line">   current: '\\0',
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    peek_buffer: VecDeque::new(),
</span></span>};</code></pre>
<p>Now, let's make our <code>peek</code> method! Here, we should advance <code>Chars</code> and push the
result to <code>peek_buffer</code>.</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">char</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>peek_buffer<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>c
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> next <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>input<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or</span><span class="token punctuation">(</span>'\\<span class="token number">0</span>'<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>peek_buffer<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        next
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>If our peek buffer already has something in it, we should just return that
character, as we want to be able to call <code>peek()</code> an arbitrary number of times
and always get the same result back.</p>
<p>Now, we must make a small modification to <code>read_char()</code>. We need to consume our
peek buffer before we advance <code>Chars</code>!</p>
<pre class="language-diff"><code class="language-diff"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">if let Some(ch) = self.peek_buffer.pop_front() {
</span><span class="token prefix inserted">+</span><span class="token line">    self.current = ch;
</span><span class="token prefix inserted">+</span><span class="token line">    return;
</span><span class="token prefix inserted">+</span><span class="token line">}
</span></span>self.current = self.input.next().unwrap_or('\\0');</code></pre>
<p>At this point, we should have a working <code>peek()</code> method! Let's tokenize <code>!=</code>!
I'll write a method, <code>try_peek_eq</code>, that takes two <code>Token</code>s.</p>
<p>If the peeked character is an <code>=</code>, we return the first argument. If not, we
return the second one. <code>self.try_peek_eq(Token::NotEq, Token::Bang)</code> will return
<code>Token::Bang</code> if the peeked character is <strong>not</strong> <code>=</code>, and <code>NotEq</code> if it is.</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">try_peek_eq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> matched<span class="token punctuation">:</span> <span class="token class-name">Token</span><span class="token punctuation">,</span> not_matched<span class="token punctuation">:</span> <span class="token class-name">Token</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Token</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'='</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">read_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        matched
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        not_matched
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>Finally, we can put it all together into <code>next_token</code>!</p>
<pre class="language-diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   '\\0' => Token::EOF,
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   '!' => self.try_peek_eq(Token::NotEq, Token::Bang),
</span></span>};</code></pre>
<p>We'll also need this for <code>&lt;=</code>, <code>&gt;=</code>, and the like, so I'll add those in really
quick.</p>
<pre class="language-diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   '\\0' => Token::EOF,
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   '!' => self.try_peek_eq(Token::NotEq, Token::Bang),
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    '=' => self.try_peek_eq(Token::Eq, Token::Assign),
</span><span class="token prefix inserted">+</span><span class="token line">    '&lt;' => self.try_peek_eq(Token::Le, Token::Langle),
</span><span class="token prefix inserted">+</span><span class="token line">    '>' => self.try_peek_eq(Token::Ge, Token::Rangle),
</span></span>};</code></pre>
<p>Great! Let's write a test for those, too.</p>
<pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[test]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">lexes_complex_tokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> lexer <span class="token operator">=</span> <span class="token class-name">Lexer</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"!=&lt;>="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> expecteds <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">NotEq</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Langle</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Ge</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token constant">EOF</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> expecteds <span class="token punctuation">{</span>
        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> lexer<span class="token punctuation">.</span><span class="token function">next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>Passed! With that, we can move on to another part of our lexer!</p>
<h2 id="reading-identifiers" tabindex="-1"><a class="header-anchor" href="#reading-identifiers">Reading Identifiers</a></h2>
<p>Our lexer also has to be able read identifiers. For example, when we input
<code>hello</code> to our lexer, it should give us <code>Token::Ident(&quot;hello&quot;)</code>.</p>
<p>Let's start by adding a case in the <code>next_token</code> method!</p>
<pre class="language-diff"><code class="language-diff"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">ch if ch == '_' || ch.is_alphabetic() => {
</span><span class="token prefix inserted">+</span><span class="token line">    let ident = self.read_ident();
</span><span class="token prefix inserted">+</span><span class="token line">    return match ident.as_str() {
</span><span class="token prefix inserted">+</span><span class="token line">        "return" => Token::Return,
</span><span class="token prefix inserted">+</span><span class="token line">        _ => Token::Ident(ident),
</span><span class="token prefix inserted">+</span><span class="token line">    };
</span><span class="token prefix inserted">+</span><span class="token line">}
</span></span></code></pre>
<p>We know that whenever we encounter an alphabetic (or <code>_</code>) character, our lexer
has either reached an identifier or a keyword. In that case, we call the
<code>read_ident()</code> method. This method advances our lexer until the end of the
identifier is found, returning it in a <code>String</code>. Then, we do some simple
matching to produce the final token!</p>
<p>It is important to note the <code>return</code> here. Our <code>next_token()</code> method advances
our lexer by one right before returning (at the very bottom of the method). By
returning early from the <code>match</code> arm, we <em>circumvent</em> this advancement. If we
didn't, we'd lose a character, because <code>read_ident()</code> already advances our lexer
to the next character after the identifier.</p>
<p>Speaking of <code>read_ident()</code>, we should probably define that!</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">read_ident</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> ident <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token keyword">self</span><span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">is_alphabetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">self</span><span class="token punctuation">.</span>current <span class="token operator">==</span> <span class="token char">'_'</span> <span class="token operator">||</span> <span class="token keyword">self</span><span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">is_ascii_digit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ident<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">read_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ident
<span class="token punctuation">}</span></code></pre>
<p>The implementation is nothing special, so I won't bore you the details. With
that out of the way, we can get to handling whitespace!</p>
<h2 id="whitespace" tabindex="-1"><a class="header-anchor" href="#whitespace">Whitespace</a></h2>
<p>For this post, we'll be ignoring whitespace completely for the sake of brevity.
In full lexers, it's usually good to not <em>completely</em> ignore them, if only
because our tokens should usually have location spans attached to them.</p>
<p>Anyway, to achieve whitespace insignificance, we need a single method:</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">skip_whitespace</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token keyword">self</span><span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">is_ascii_whitespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">read_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>Pretty simple! And we'll only need it in one place (for now)!</p>
<pre class="language-diff"><code class="language-diff">pub fn next_token(&amp;mut self) -> Token {
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    self.skip_whitespace();
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   let token = match self.current {
</span></span></code></pre>
<p>Now, whenever we call <code>next_token()</code> all whitespace is skipped!</p>
<p>And with that...... Congrats! You've built a basic lexer! At this point, I'd say
the lexer has enough to extend it with your own features and tokens! Let's write
some celebratory tests and move on to the next big challenge: automatic
semicolon insertion.</p>
<pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[test]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">lexer_skips_whitespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> lexer <span class="token operator">=</span> <span class="token class-name">Lexer</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>
        <span class="token string">",    ; ==
            !"</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> expecteds <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Comma</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Semicolon</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Eq</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Bang</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token constant">EOF</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> expecteds <span class="token punctuation">{</span>
        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> lexer<span class="token punctuation">.</span><span class="token function">next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>Passed!</p>
<h2 id="automatic-semicolon-insertion" tabindex="-1"><a class="header-anchor" href="#automatic-semicolon-insertion">Automatic Semicolon Insertion</a></h2>
<p>With our current lexer setup, adding automatic semicolon insertion should be
pretty simple! We'll be following in the footsteps of the
<a href="https://go.dev">Go language</a> and their
<a href="https://go.dev/ref/spec#Semicolons">semicolon specification</a>. If you're not
familiar with it, Go has a very simple rule in their lexer:</p>
<p>A semicolon is inserted if the last token in a line is an:</p>
<ol>
<li>Identifier</li>
<li>Literal</li>
<li>One of: <code>break</code>, <code>continue</code>, <code>fallthrough</code>, or <code>return</code></li>
<li>One of the operators/punctuation: <code>++</code>, <code>--</code>, <code>)</code>, <code>]</code>, <code>}</code></li>
</ol>
<p>For our current token set, our lexer needs to insert a semicolon after it finds
an:</p>
<ol>
<li>Identifier</li>
<li><code>return</code></li>
<li><code>)</code> or <code>}</code></li>
</ol>
<p>First, let's define what we need to do in order to actually &quot;insert&quot; a
semicolon.</p>
<p>After reading one of the three things listed above, we'll see if our lexer's
current character is a newline. If so, we'll add a semicolon to the front of our
peek buffer. Since we'll have a semicolon at the front, our <code>read_char</code> will
consume that instead of more input! This isn't actually &quot;inserting&quot; anything,
more just queueing it into our token stream!</p>
<p>Let's define a method, <code>try_insert_semicolon()</code> that we can call whenever we
<em>might</em> have a semicolon that needs to be inserted.</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">try_insert_semicolon</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Skip whitespace before possible semicolon</span>
    <span class="token keyword">while</span> <span class="token keyword">self</span><span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">is_ascii_whitespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>current <span class="token operator">!=</span> '\\n' <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">read_char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Also handle edge case of the null byte being last</span>
    <span class="token keyword">if</span> <span class="token macro property">matches!</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>current<span class="token punctuation">,</span> '\\n' <span class="token operator">|</span> '\\<span class="token number">0</span>'<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>peek_buffer<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token char">';'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>We first skip any whitespace that might precede our possible semicolon. We do
this to allow semicolons inserted in a line with trailing whitespace. The rest
is pretty simple!</p>
<p>With the <code>try_insert_semicolon()</code> method in place, we can call it where needed!
Let's start with identifiers.</p>
<pre class="language-diff"><code class="language-diff">ch if ch == '_' || ch.is_alphabetic() => {
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   let ident = self.read_ident();
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    self.try_insert_semicolon();
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   return match ident.as_str() {
</span></span></code></pre>
<p>Nice and simple! This handles both case one and two of our insertion rules. Now,
we can move on to <code>}</code> and <code>)</code>.</p>
<pre class="language-diff"><code class="language-diff"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">')' => {
</span><span class="token prefix inserted">+</span><span class="token line">    self.read_char();
</span><span class="token prefix inserted">+</span><span class="token line">    self.try_insert_semicolon();
</span><span class="token prefix inserted">+</span><span class="token line">    Token::Rparen
</span><span class="token prefix inserted">+</span><span class="token line">}
</span><span class="token prefix inserted">+</span><span class="token line">'}' => {
</span><span class="token prefix inserted">+</span><span class="token line">    self.read_char();
</span><span class="token prefix inserted">+</span><span class="token line">    self.try_insert_semicolon();
</span><span class="token prefix inserted">+</span><span class="token line">    Token::Rbrace
</span><span class="token prefix inserted">+</span><span class="token line">}
</span></span>
'!' => self.try_peek_eq(Token::NotEq, Token::Bang),</code></pre>
<p>To get these to work, we need to advance our lexer by one (past the <code>)</code> or <code>}</code>),
which will set us up to use <code>try_insert_semicolon()</code>, a consequence of the way
we wrote the method.</p>
<p>As you might've expected by now, we're gonna write a test for this behavior!</p>
<pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[test]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">lexer_inserts_semicolons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> lexer <span class="token operator">=</span> <span class="token class-name">Lexer</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>
        <span class="token string">"ident
    return
    function()
    {-}"</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> expecteds <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Ident</span><span class="token punctuation">(</span><span class="token string">"ident"</span><span class="token punctuation">.</span><span class="token function">to_owned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Semicolon</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Return</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Semicolon</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Ident</span><span class="token punctuation">(</span><span class="token string">"function"</span><span class="token punctuation">.</span><span class="token function">to_owned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Lparen</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Rparen</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Semicolon</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Lbrace</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Minus</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Rbrace</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token class-name">Semicolon</span><span class="token punctuation">,</span>
        <span class="token class-name">Token</span><span class="token punctuation">::</span><span class="token constant">EOF</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> t <span class="token keyword">in</span> expecteds <span class="token punctuation">{</span>
        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> lexer<span class="token punctuation">.</span><span class="token function">next_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>Great! Whew! We're done!</p>
<h2 id="wrapping-up" tabindex="-1"><a class="header-anchor" href="#wrapping-up">Wrapping Up</a></h2>
<p>If you've read this far, I hope you enjoyed and found use from this post.
Although the lexer defined in this tutorial is definitely <em>not</em> complete, my
hope is that it's not too hard to extend it.</p>
<p>The roots of this post lie in Thorsten Ball's excellent book,
<a href="https://interpreterbook.com/">Writing an Interpreter in Go</a>. The design of the
lexer featured in this post is largely similar to that of the book's, with the
main addition being the semicolon insertion. I highly recommend the book for any
future programming language endeavors you might find yourself on; it's short,
easy to grasp, and leaves with you with just enough information for you to add
your own features!</p>
<p>As always, if there are any issues in the post, please don't hesitate to submit
an <a href="https://github.com/dzfrias/blog/issues/new">issue on GitHub</a>!</p>


      </main>
    </div>
    <div id="main-right">
      
      
    </div>
  </body>
</html>
